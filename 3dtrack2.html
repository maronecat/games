<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magic Tree: Star & Implosion</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; }
        #input_video { display: none; }
        #output_canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #info {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.9); z-index: 2; font-family: sans-serif;
            pointer-events: none; text-shadow: 0 0 5px cyan; font-size: 0.9rem; line-height: 1.6;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; z-index: 3; font-family: monospace; font-size: 1.2rem;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading">Summoning Christmas...</div>
    <div id="info">
        âœŒï¸ <b>ãƒãƒ§ã‚­</b>ï¼šæ˜Ÿã‚’ç¯ã™ã€€âœŠ <b>ã‚°ãƒ¼</b>ï¼šåœ§ç¸®ã™ã‚‹<br>
        âœ‹ <b>ãƒ‘ãƒ¼</b>ï¼šè‰²ã‚’å¤‰ãˆã‚‹ã€€ğŸ‘Œ <b>ãƒ”ãƒ³ãƒ</b>ï¼šãƒ„ãƒªãƒ¼â‡”é›ª
    </div>
    
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>

<script>
    // --- 1. ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆ (ç²’å­ç”¨ & æ˜Ÿç”¨) ---
    function createGlowTexture(isStar = false) {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        if (isStar) {
            // æ˜Ÿã¯ã‚ˆã‚Šé‹­ãã€ä¸­å¿ƒãŒæ˜ã‚‹ã„
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.1, 'rgba(255, 255, 220, 1)');
            gradient.addColorStop(0.4, 'rgba(255, 200, 100, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        } else {
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯ãµã‚ã£ã¨
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        return new THREE.CanvasTexture(canvas);
    }

    // --- 2. Three.js åˆæœŸè¨­å®š ---
    const canvas = document.getElementById('output_canvas');
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020205, 0.04);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 8);

    // --- 3. ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ»ãƒ„ãƒªãƒ¼æ§‹ç¯‰ ---
    const particleCount = 2500;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const basePositions = [];
    const scatterOffsets = [];
    const particleTypes = []; // 0:Main, 1:Sub

    // ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ
    const palettes = [
        { main: new THREE.Color(0x00ff88), sub: new THREE.Color(0xffaa00) }, // ç·‘Ã—é‡‘
        { main: new THREE.Color(0x0088ff), sub: new THREE.Color(0xffffff) }, // é’Ã—ç™½
        { main: new THREE.Color(0xff4444), sub: new THREE.Color(0xffffff) }, // èµ¤Ã—ç™½
        { main: new THREE.Color(0xff00ff), sub: new THREE.Color(0x00ffff) }  // ãƒã‚ªãƒ³
    ];
    let currentPaletteIndex = 0;
    let targetColorMain = palettes[0].main;
    let targetColorSub = palettes[0].sub;
    const colorSnow = new THREE.Color(0xffffff);

    for (let i = 0; i < particleCount; i++) {
        const y = Math.random() * 6 - 3;
        const radius = (3 - y) * 0.4 + 0.1;
        const angle = y * 5 + Math.random() * Math.PI * 2;
        
        const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 0.5;
        const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 0.5;

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        basePositions.push({x, y, z});
        scatterOffsets.push(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize());

        const isSub = Math.random() > 0.85;
        particleTypes.push(isSub ? 1 : 0);
        
        const c = isSub ? targetColorSub : targetColorMain;
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.15, map: createGlowTexture(false), vertexColors: true,
        blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
    });
    const particlesMesh = new THREE.Points(geometry, material);
    scene.add(particlesMesh);

    // --- 4. æ˜Ÿ (Star) ã®ä½œæˆ ---
    const starMaterial = new THREE.SpriteMaterial({ 
        map: createGlowTexture(true), 
        color: 0xffffaa, 
        blending: THREE.AdditiveBlending 
    });
    const starSprite = new THREE.Sprite(starMaterial);
    starSprite.scale.set(1.5, 1.5, 1.0);
    starSprite.position.set(0, 3.2, 0); // ãƒ„ãƒªãƒ¼ã®ã¦ã£ãºã‚“
    starSprite.visible = false; // æœ€åˆã¯æ¶ˆã—ã¦ãŠã
    scene.add(starSprite);

    // --- 5. ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡å¤‰æ•° ---
    let targetScale = 1.0;
    let currentScale = 1.0;
    let explosionFactor = 0.0;
    let handDetected = false;
    let lastColorChangeTime = 0;
    
    // ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼çŠ¶æ…‹
    let isFist = false;
    let isPeace = false;
    let isOpen = false;

    function animate() {
        requestAnimationFrame(animate);

        // ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        currentScale += (targetScale - currentScale) * 0.1;

        // çˆ†ç™º(é›ªåŒ–)ä¿‚æ•°ã®è¨ˆç®—: ã‚¹ã‚±ãƒ¼ãƒ«ãŒå¤§ãã„ã¨é›ªã«ãªã‚‹
        let targetExplosion = (currentScale > 2.0) ? Math.min((currentScale - 2.0) * 0.8, 1.5) : 0;
        explosionFactor += (targetExplosion - explosionFactor) * 0.05;

        const time = Date.now() * 0.001;
        const posAttr = geometry.attributes.position;
        const colAttr = geometry.attributes.color;

        for (let i = 0; i < particleCount; i++) {
            const bx = basePositions[i].x;
            const by = basePositions[i].y;
            const bz = basePositions[i].z;
            const sx = scatterOffsets[i].x;
            const sy = scatterOffsets[i].y;
            const sz = scatterOffsets[i].z;

            // é€šå¸¸ã®ã‚†ã‚‰ã
            const wobble = Math.sin(time * 2 + by) * 0.03; 

            // é›ªãƒ¢ãƒ¼ãƒ‰ã®å‹•ã
            const snowX = sx * 5.0 + Math.sin(time * 0.5 + i) * 0.5;
            const snowY = sy * 5.0 + Math.cos(time * 0.3 + i) * 0.5;
            const snowZ = sz * 5.0 + Math.sin(time * 0.7 + i) * 0.5;

            // ä½ç½®ãƒ–ãƒ¬ãƒ³ãƒ‰ (ãƒ„ãƒªãƒ¼ <-> é›ª)
            let px = bx + (snowX - bx) * explosionFactor;
            let py = by + (snowY - by) * explosionFactor;
            let pz = bz + (snowZ - bz) * explosionFactor;

            // æœ€çµ‚åº§æ¨™ã‚»ãƒƒãƒˆ
            posAttr.setXYZ(i, px * currentScale, py * currentScale, pz * currentScale);

            // è‰²ãƒ–ãƒ¬ãƒ³ãƒ‰
            const baseC = (particleTypes[i] === 1) ? targetColorSub : targetColorMain;
            const curR = colAttr.getX(i);
            const curG = colAttr.getY(i);
            const curB = colAttr.getZ(i);

            // é›ªã«ãªã‚‹ã¨ç™½ããªã‚‹
            const finalR = baseC.r + (colorSnow.r - baseC.r) * explosionFactor;
            const finalG = baseC.g + (colorSnow.g - baseC.g) * explosionFactor;
            const finalB = baseC.b + (colorSnow.b - baseC.b) * explosionFactor;

            // è‰²ã‚’æ»‘ã‚‰ã‹ã«å¤‰æ›´
            colAttr.setXYZ(i,
                curR + (finalR - curR) * 0.05,
                curG + (finalG - curG) * 0.05,
                curB + (finalB - curB) * 0.05
            );
        }
        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true;

        // æ˜Ÿã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ (ã‚­ãƒ©ã‚­ãƒ©)
        if (starSprite.visible) {
            const pulse = 1.2 + Math.sin(time * 5) * 0.3;
            starSprite.scale.set(pulse, pulse, 1.0);
            // æ˜Ÿã‚‚ãƒ„ãƒªãƒ¼ã¨ä¸€ç·’ã«å›è»¢
            starSprite.position.x = 0;
            starSprite.position.z = 0;
            // åº§æ¨™å¤‰æ›ã‚’å…¥ã‚Œã‚‹ã¨ã‚ˆã‚Šãƒªã‚¢ãƒ«ã ãŒã€ç°¡æ˜“çš„ã«å¸¸ã«ä¸Šéƒ¨ã«é…ç½®
            // (æ‰‹ã§å›è»¢ã•ã›ãŸã¨ãã«è¿½å¾“ã•ã›ã‚‹ãŸã‚ã€Meshã®å­è¦ç´ ã«ã™ã‚‹ã®ãŒæœ¬æ¥ã ãŒä»Šå›ã¯ç°¡æ˜“å®Ÿè£…)
        }

        // æ‰‹ãŒãªã„ã¨ãã¯è‡ªå‹•å›è»¢
        if (!handDetected) particlesMesh.rotation.y += 0.005;

        renderer.render(scene, camera);
    }
    animate();

    // --- 6. ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ ---
    const videoElement = document.getElementById('input_video');
    const loadingElement = document.getElementById('loading');

    function onResults(results) {
        loadingElement.style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handDetected = true;
            const landmarks = results.multiHandLandmarks[0];

            // å„æŒ‡ã®ã€ŒæŒ‡å…ˆ(TIP)ã€ã¨ã€Œç¬¬2é–¢ç¯€(PIP)ã€ã‚’å–å¾—
            // Yåº§æ¨™ã¯ç”»é¢ä¸ŠãŒ0ã€ä¸‹ãŒ1ãªã®ã§ã€TIP < PIP ãªã‚‰ã€ŒæŒ‡ãŒä¼¸ã³ã¦ã„ã‚‹ã€
            const isIndexOpen  = landmarks[8].y  < landmarks[6].y;
            const isMiddleOpen = landmarks[12].y < landmarks[10].y;
            const isRingOpen   = landmarks[16].y < landmarks[14].y;
            const isPinkyOpen  = landmarks[20].y < landmarks[18].y;
            // è¦ªæŒ‡ã¯Xåº§æ¨™ãªã©ã§è¦‹ã‚‹ã®ãŒæ­£ç¢ºã ãŒã€ç°¡æ˜“çš„ã«ã€Œäººå·®ã—æŒ‡ã‹ã‚‰é›¢ã‚Œã¦ã„ã‚‹ã‹ã€ç­‰ã§è¦‹ã‚‹
            // ã“ã“ã§ã¯ç°¡æ˜“çš„ã«4æœ¬ã®æŒ‡ã§åˆ¤å®š

            // --- ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼åˆ¤å®š ---
            
            // âœŠ ã‚°ãƒ¼ (Fist): äººå·®ã—æŒ‡ã€œå°æŒ‡ãŒã™ã¹ã¦é–‰ã˜ã¦ã„ã‚‹
            isFist = !isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen;

            // âœŒï¸ ãƒãƒ§ã‚­ (Peace): äººå·®ã—æŒ‡ãƒ»ä¸­æŒ‡OPENã€è–¬æŒ‡ãƒ»å°æŒ‡CLOSE
            isPeace = isIndexOpen && isMiddleOpen && !isRingOpen && !isPinkyOpen;

            // âœ‹ ãƒ‘ãƒ¼ (Open): 4æœ¬ã™ã¹ã¦OPEN (è¦ªæŒ‡ã‚‚å«ã‚ãŸã„ãŒèª¤æ¤œçŸ¥æ¸›ã‚‰ã™ãŸã‚4æœ¬+è¦ªæŒ‡è·é›¢ã§åˆ¤å®šã‚‚å¯)
            // ä»Šå›ã¯å³å¯†ã«ã€Œå…¨éƒ¨ä¼¸ã³ã¦ã‚‹ã€åˆ¤å®š
            isOpen = isIndexOpen && isMiddleOpen && isRingOpen && isPinkyOpen;

            
            // --- ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®é©ç”¨ ---

            // 1. æ˜Ÿã®åˆ¶å¾¡ (ãƒãƒ§ã‚­)
            starSprite.visible = isPeace;
            if (isPeace) {
                // ãƒãƒ§ã‚­ã®ã¨ãã¯ãƒ„ãƒªãƒ¼å½¢çŠ¶(ã‚¹ã‚±ãƒ¼ãƒ«1)ã‚’å¼·åˆ¶
                targetScale = 1.0; 
            }

            // 2. åœ§ç¸®ã®åˆ¶å¾¡ (ã‚°ãƒ¼)
            if (isFist) {
                // ãã—ã‚ƒã£ã¨å†…åŒ… (æ¥µå°ã‚¹ã‚±ãƒ¼ãƒ«)
                targetScale = 0.2; 
            }

            // 3. ã‚«ãƒ©ãƒ¼ãƒã‚§ãƒ³ã‚¸ (ãƒ‘ãƒ¼)
            if (isOpen) {
                const now = Date.now();
                if (now - lastColorChangeTime > 1500) { // 1.5ç§’ã«1å›ã ã‘
                    changeColorPalette();
                    lastColorChangeTime = now;
                }
                // ãƒ‘ãƒ¼ã®ã¨ãã¯ã€ŒæŒ‡ãŒé–‹ã„ã¦ã„ã‚‹ã€ã®ã§ã€é€šå¸¸ãƒ­ã‚¸ãƒƒã‚¯ã ã¨é›ªã«ãªã‚‹
                // ãã®ã¾ã¾ã§OK (é›ªã«ãªã‚ŠãªãŒã‚‰è‰²ãŒå¤‰ã‚ã‚‹ã®ãŒç¶ºéº—)
            }

            // 4. åŸºæœ¬ã®ãƒ”ãƒ³ãƒæ“ä½œ (ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ä»¥å¤–)
            if (!isFist && !isPeace) {
                // è¦ªæŒ‡ã¨äººå·®ã—æŒ‡ã®è·é›¢ã§ã‚¹ã‚±ãƒ¼ãƒ«è¨ˆç®—
                const thumb = landmarks[4];
                const index = landmarks[8];
                const distance = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
                
                // è·é›¢0.05(é–‰) -> Scale 1.0
                // è·é›¢0.40(é–‹) -> Scale 4.0
                targetScale = 1.0 + (distance * 8.0);
            }

            // æ‰‹ã®ä½ç½®ã§å›è»¢
            const handCenterX = landmarks[9].x; // æ‰‹ã®ã²ã‚‰ä¸­å¿ƒ
            particlesMesh.rotation.y = (handCenterX - 0.5) * -3;
            particlesMesh.rotation.x = (landmarks[9].y - 0.5) * -2;
            
            // æ˜Ÿã®ä½ç½®åˆã‚ã› (ç°¡æ˜“)
            // æ˜Ÿã‚‚ãƒ„ãƒªãƒ¼ã¨åŒã˜å›è»¢ã‚’ä¸ãˆã‚‹
            starSprite.position.x = 0; // ä¸­å¿ƒå›ºå®šã ãŒã€å›è»¢ãƒ­ã‚¸ãƒƒã‚¯ã¨åˆã‚ã›ã‚‹ãªã‚‰Meshã«å…¥ã‚Œã‚‹ã¹ã
            // ä»Šå›ã¯Spriteãªã®ã§å¸¸ã«æ­£é¢ã‚’å‘ãç‰¹æ€§ãŒã‚ã‚‹ã€‚ä½ç½®ã ã‘è¿½å¾“ã•ã›ã‚‹ã®ã¯è¤‡é›‘ã«ãªã‚‹ã®ã§
            // ã€Œãƒ„ãƒªãƒ¼ã®ã¦ã£ãºã‚“ã€ã«å›ºå®šã—ã¦ãŠãã®ãŒä¸€ç•ªç¶ºéº—ã«è¦‹ãˆã¾ã™ã€‚

        } else {
            handDetected = false;
            starSprite.visible = false;
            targetScale = 1.0;
        }
    }

    function changeColorPalette() {
        currentPaletteIndex = (currentPaletteIndex + 1) % palettes.length;
        const p = palettes[currentPaletteIndex];
        targetColorMain = p.main;
        targetColorSub = p.sub;
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraUtils.start();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
